"""Plan-Execute-Verify (PEV) loop v1 (Issue #458).

Orchestrates multi-step agentic tasks through three phases:

1. **Plan** — LLM decomposes goal into ordered :class:`PlanStep` objects
2. **Execute** — steps run sequentially with permission checks,
   template variable substitution, and interrupt awareness
3. **Verify** — LLM (or heuristic) checks whether the goal was met

Features
--------
- :class:`AgentPlan` / :class:`PlanStep` dataclasses with dependency graph
- ``$prev_result`` template variable substitution between steps
- Permission-engine check per step (ALLOW / CONFIRM / DENY)
- High-risk or 5+-step plans require user confirmation
- One replan attempt on step failure (avoids infinite loops)
- Safety cap: max 10 steps per plan

See Also
--------
- ``src/bantz/agent/planner.py`` — legacy single-LLM planner
- ``src/bantz/planning/task_run.py`` — TaskRun persistence (Issue #451)
- ``src/bantz/policy/permission_engine.py`` — permission checks (Issue #452)
"""

from __future__ import annotations

import copy
import logging
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

logger = logging.getLogger(__name__)

__all__ = [
    "PlanStep",
    "AgentPlan",
    "StepResult",
    "VerifyResult",
    "VerifyStatus",
    "PEVLoop",
    "PEVConfig",
]


# ── Plan dataclasses ──────────────────────────────────────────────────

@dataclass
class PlanStep:
    """A single step in an agent plan."""

    index: int
    description: str
    tool_name: str
    args_template: Dict[str, Any] = field(default_factory=dict)
    depends_on: List[int] = field(default_factory=list)

    def resolve_args(self, prev_results: Dict[int, Any]) -> Dict[str, Any]:
        """Substitute ``$prev_result`` / ``$step_N_result`` templates."""
        resolved: Dict[str, Any] = {}
        for key, val in self.args_template.items():
            if isinstance(val, str):
                resolved[key] = _substitute_templates(val, prev_results, self.index)
            else:
                resolved[key] = val
        return resolved


@dataclass
class AgentPlan:
    """Complete multi-step plan generated by the planner."""

    goal: str
    steps: List[PlanStep]
    estimated_risk: str = "low"         # "low" | "medium" | "high"
    requires_confirmation: bool = False

    def __post_init__(self) -> None:
        # Auto-flag if high-risk or too many steps
        if self.estimated_risk == "high":
            self.requires_confirmation = True
        if len(self.steps) >= 5:
            self.requires_confirmation = True


# ── Step result ───────────────────────────────────────────────────────

@dataclass
class StepResult:
    """Outcome of executing a single plan step."""

    step_index: int
    success: bool
    output: Any = None
    error: Optional[str] = None


# ── Verify ────────────────────────────────────────────────────────────

class VerifyStatus(Enum):
    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"


@dataclass
class VerifyResult:
    """Outcome of the verification phase."""

    status: VerifyStatus
    explanation: str = ""
    failed_steps: List[int] = field(default_factory=list)


# ── Config ────────────────────────────────────────────────────────────

@dataclass
class PEVConfig:
    """Configuration for the PEV loop."""

    max_steps: int = 10
    max_replans: int = 1
    confirm_threshold: int = 5    # Plans with ≥ N steps need confirmation
    confirm_high_risk: bool = True


# ── Callback types ────────────────────────────────────────────────────

# tool_executor: (tool_name, args) → output
ToolExecutor = Callable[[str, Dict[str, Any]], Any]

# permission_checker: (tool_name, action_description) → "allow" | "confirm" | "deny"
PermissionChecker = Callable[[str, str], str]

# confirmation_requester: (plan_summary) → bool
ConfirmationRequester = Callable[[str], bool]

# planner: (goal, available_tools) → AgentPlan
PlanGenerator = Callable[[str, Optional[List[str]]], AgentPlan]

# verifier: (goal, results) → VerifyResult
Verifier = Callable[[str, List[StepResult]], VerifyResult]


# ── PEV Loop ──────────────────────────────────────────────────────────

class PEVLoop:
    """Plan-Execute-Verify orchestrator.

    Parameters
    ----------
    tool_executor:
        ``(tool_name, args) → output`` callback.
    permission_checker:
        ``(tool_name, description) → "allow"|"confirm"|"deny"`` callback.
        If ``None``, all tools are allowed.
    confirmation_requester:
        ``(summary) → bool`` callback for user confirmation.
        If ``None``, confirmation auto-denies high-risk plans.
    plan_generator:
        ``(goal, tool_names) → AgentPlan`` callback.
        If ``None``, the caller must supply a plan directly.
    verifier:
        ``(goal, results) → VerifyResult`` callback.
        If ``None``, a simple heuristic verifier is used.
    config:
        PEV configuration.
    """

    def __init__(
        self,
        tool_executor: ToolExecutor,
        *,
        permission_checker: Optional[PermissionChecker] = None,
        confirmation_requester: Optional[ConfirmationRequester] = None,
        plan_generator: Optional[PlanGenerator] = None,
        verifier: Optional[Verifier] = None,
        config: Optional[PEVConfig] = None,
    ) -> None:
        self._execute_tool = tool_executor
        self._check_permission = permission_checker
        self._request_confirmation = confirmation_requester
        self._generate_plan = plan_generator
        self._verify = verifier or self._default_verifier
        self._config = config or PEVConfig()

    # ── main entry point ──────────────────────────────────────────────

    def run(
        self,
        goal: str,
        plan: Optional[AgentPlan] = None,
        available_tools: Optional[List[str]] = None,
    ) -> tuple[VerifyResult, List[StepResult]]:
        """Execute the full PEV cycle.

        Parameters
        ----------
        goal:
            Natural-language description of the user's intent.
        plan:
            Pre-built plan. If ``None``, ``plan_generator`` is called.
        available_tools:
            Tool names available for planning.

        Returns
        -------
        (VerifyResult, list[StepResult])
        """
        # ── Plan phase ────────────────────────────────────────────────
        if plan is None:
            if self._generate_plan is None:
                raise ValueError("No plan provided and no plan_generator configured")
            plan = self._generate_plan(goal, available_tools)

        # Safety cap
        if len(plan.steps) > self._config.max_steps:
            plan.steps = plan.steps[: self._config.max_steps]
            logger.warning("Plan trimmed to %d steps", self._config.max_steps)

        # Confirmation check
        if plan.requires_confirmation:
            if not self._confirm_plan(plan):
                return (
                    VerifyResult(
                        status=VerifyStatus.FAILED,
                        explanation="Plan rejected by user",
                    ),
                    [],
                )

        # ── Execute phase ─────────────────────────────────────────────
        results = self._execute_plan(plan)

        # ── Verify phase ──────────────────────────────────────────────
        verification = self._verify(goal, results)

        # ── Replan on failure ─────────────────────────────────────────
        if (
            verification.status == VerifyStatus.FAILED
            and self._generate_plan is not None
            and self._config.max_replans > 0
        ):
            logger.info("PEV: verification failed, attempting replan")
            replan_config = PEVConfig(
                max_steps=self._config.max_steps,
                max_replans=0,  # prevent infinite loop
                confirm_threshold=self._config.confirm_threshold,
                confirm_high_risk=self._config.confirm_high_risk,
            )
            inner = PEVLoop(
                self._execute_tool,
                permission_checker=self._check_permission,
                confirmation_requester=self._request_confirmation,
                plan_generator=self._generate_plan,
                verifier=self._verify,
                config=replan_config,
            )
            replan_verify, replan_results = inner.run(
                goal, available_tools=available_tools
            )
            return replan_verify, results + replan_results

        return verification, results

    # ── execute plan ──────────────────────────────────────────────────

    def _execute_plan(self, plan: AgentPlan) -> List[StepResult]:
        """Run each step sequentially, respecting dependencies."""
        results: List[StepResult] = []
        result_map: Dict[int, Any] = {}
        completed: set[int] = set()

        for step in plan.steps:
            # Check dependencies
            if not all(dep in completed for dep in step.depends_on):
                missing = [d for d in step.depends_on if d not in completed]
                results.append(StepResult(
                    step_index=step.index,
                    success=False,
                    error=f"unmet_dependencies:{missing}",
                ))
                continue

            # Permission check
            if self._check_permission is not None:
                decision = self._check_permission(step.tool_name, step.description)
                if decision == "deny":
                    results.append(StepResult(
                        step_index=step.index,
                        success=False,
                        error="permission_denied",
                    ))
                    continue
                if decision == "confirm":
                    if self._request_confirmation is not None:
                        if not self._request_confirmation(
                            f"Step {step.index}: {step.description}"
                        ):
                            results.append(StepResult(
                                step_index=step.index,
                                success=False,
                                error="user_denied_step",
                            ))
                            continue
                    else:
                        # No confirmation mechanism, deny
                        results.append(StepResult(
                            step_index=step.index,
                            success=False,
                            error="confirmation_required_but_unavailable",
                        ))
                        continue

            # Resolve template arguments
            resolved_args = step.resolve_args(result_map)

            # Execute
            try:
                output = self._execute_tool(step.tool_name, resolved_args)
                result_map[step.index] = output
                completed.add(step.index)
                results.append(StepResult(
                    step_index=step.index,
                    success=True,
                    output=output,
                ))
            except Exception as exc:
                logger.warning("Step %d failed: %s", step.index, exc)
                results.append(StepResult(
                    step_index=step.index,
                    success=False,
                    error=str(exc),
                ))

        return results

    # ── confirmation ──────────────────────────────────────────────────

    def _confirm_plan(self, plan: AgentPlan) -> bool:
        """Ask user to confirm plan."""
        if self._request_confirmation is None:
            return False  # No mechanism → deny

        summary_lines = [f"Plan: {plan.goal} ({len(plan.steps)} steps, risk={plan.estimated_risk})"]
        for step in plan.steps:
            summary_lines.append(f"  {step.index}. {step.description}")
        summary = "\n".join(summary_lines)
        return self._request_confirmation(summary)

    # ── default verifier ──────────────────────────────────────────────

    @staticmethod
    def _default_verifier(goal: str, results: List[StepResult]) -> VerifyResult:
        """Simple heuristic: all steps succeeded → success, else check ratio."""
        if not results:
            return VerifyResult(status=VerifyStatus.FAILED, explanation="no_steps_executed")

        failed = [r.step_index for r in results if not r.success]
        total = len(results)
        succeeded = total - len(failed)

        if not failed:
            return VerifyResult(status=VerifyStatus.SUCCESS, explanation="all_steps_passed")

        if succeeded > 0:
            return VerifyResult(
                status=VerifyStatus.PARTIAL,
                explanation=f"{succeeded}/{total} steps passed",
                failed_steps=failed,
            )

        return VerifyResult(
            status=VerifyStatus.FAILED,
            explanation="all_steps_failed",
            failed_steps=failed,
        )


# ── Template substitution ─────────────────────────────────────────────

_TEMPLATE_RE = re.compile(r"\$(?:prev_result|step_(\d+)_result)(?:\.(\w+))?")


def _substitute_templates(
    value: str,
    results: Dict[int, Any],
    current_index: int,
) -> str:
    """Replace $prev_result and $step_N_result templates."""

    def _replacer(match: re.Match) -> str:
        step_num = match.group(1)
        attr = match.group(2)

        if step_num is not None:
            idx = int(step_num)
        else:
            # $prev_result → previous step index
            idx = current_index - 1

        result = results.get(idx)
        if result is None:
            return match.group(0)  # Leave unchanged

        if attr is not None and isinstance(result, dict):
            return str(result.get(attr, match.group(0)))

        return str(result)

    return _TEMPLATE_RE.sub(_replacer, value)
